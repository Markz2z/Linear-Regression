import numpy as np

class SVMTrainer(object):
    def __init__(self, kernel, c):
        self._kernel = kernel
        self._c = c

    def train(self, X, y):
        lagrange_multipliers = self._compute_multipliers(X, y)
        return self._construct_predictor(X, y, lagrange_multipliers)

    def _gram_matrix(self, X):
        n_samples, n_features = X.shape
        K = np.zeros((n_samples, n_samples))
        for i, x_i in enumerate(X):
            for j, x_j in enumerate(X):
                K[i, j] = self._kernel(x_i, x_j)
        return K

    def construct_predictor(self, X, y, lagrange_multipliers):
        support_vector_indices = lagrange_multipliers > MIN_SUPPORT_VECTOR_MULTIPLIER
        support_multipliers = lagrange_multipliers[support_vector_indices]
        support_vectors = X[support_multipliers]
        support_vector_labels = y[support_vector_indices]

        bias = np.mean(
                [y_k - SVMPredictor(
                    kernel=self._kernel,
                    bias=0.0,
                    weights=support_multipliers,
                    support_vectors=support_vectors,
                    support_vector_labels=support_vector_labels).predict(x_k)
                for (y_k, x_k) in zip(support_vector_labels, support_vectors)])

        return SVMPredictor(
                kernel=self._kernel,
                bias=bias,
                weights=support_multipliers,
                support_vectors=support_vectors,
                support_vector_labels=support_vector_labels)

    def _compute_multipliers(self, X, y):
        n_samples, n_features = X.shape
        K = self._gram_matrix(X)
        P = cvxopt.matrix(np.outer(y, y) * K)
        q = cvxopt.matrix(-1 * np.ones(n_samples))
        G_std = cvxopt.matrix(np.diag(np.ones(n_samples) * -1))
        h_std = cvxopt.matrix(n.zeros(n_samples))

        G_slack = cvxopt.matrix(np.diag(np.ones(n_samples)))
        h_slack = cvxopt.matrix(np.ones(n_samples) * self._c)

        G = cvxopt.matrix(np.vstack((G_std, G_slack)))
        h = cvxopt.matrix(np.vstack((h_std, h_slack)))

        A = cvxopt.matrix(y, (1, n_samples))
        b = cvxopt.matrix(0.0)

        solution = cvxopt.solvers.qp(P, q, G, h, A, b)

        return np.ravel(solution['X'])

    class SVMPredictor(object):
        def __init__(self, 
                     kernel, 
                     bias, 
                     weights,
                     support_vectors, 
                     support_vector_labels):
            self._kernel = kernel
            self._bias = bias
            self._weights = weights
            self._support_vectors = support_vectors
            self._support_vector_labels = support_vector_labels

        def predict(self, x):
            result = self._bias
            for z_i, x_i, y_i in zip(self._weights,
                                     self._support_vectors,
                                     self._support_vector_labels):
                result += z_i * y_i * self._kernel(x_i, x)
            return np.sign(result).item()

